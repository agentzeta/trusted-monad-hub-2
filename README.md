# truthful-ai (trusted-knowledge-on-monad)
Community built knowledge repository of consensus-verified AI answers to user generated questions across a vast array of domains

# What is truthful-ai?
Truthful-ai is a platform for a community-built knowledge-hub like quora/wikipedia based on consensus learning, but with responses generated by multiple LLMs and consensus verified using statistical techniques. The Consensus responses to questions are verified and date and time stamped and stored permanentsly on a decentralised blockchain storage system (Flare) , along with a transaction hash. The app also gives a leader board for scoring models on consensus, anti-hallucination, consistency etc which creates useful dynamically evolving signals for public consumption of model generated outputs, and also a necessary step towards an industry benchmark for evaluating models - which is a hard problem to solve. The cumulative knowledge becomes an invaluable repository of intellectual capital or a public good over time. The potential applications are numerous, both for commercial use and for highly confidential repositories for private use and reference such as in medical field. For example, overtime, this platform can potentially evolve to be a highly relaiable medical repository where doctors and healthcare providers can look up medical issue related queries for diagnosis and treatment, and can rely with a high confidence interval on the consensus responses. This innovation makes this verifiable AI tool useful for even medical novices as it eliminates the serious issue of unreliability and hallucinations and wild extrapolations that the LLMs can be prone to oftentimes. Naturally, this verifiable AI tool can be used across a myriad domains in technology, science, scientific discovery, manufacturing, STEM fields, education, health, space, and even mundane things like consumer goods, travel, and personal finance.

We have also added a web3 feature of staking, for users to start a query, and voting to reward content quality, with Truth token - truthful's native token. 

# What techniques are used for arriving at Verifiable Consensus?
The consensus derivation logic has been built from the ground up, without relying on external applications such as openrouter's consensus which relies on aggregating/synthesising LLM responses. Below are some key parameters assessed to arrive at a consensus logic. Consensus-Based Verification: A response is "verified" if it's highly similar to the consensus response Jaccard Similarity Threshold: Using our existing Jaccard similarity calculation to determine if a response is close to the consensus Confidence Score: Responses with higher confidence scores are more likely to be verifiedâ€¨â€¨ Similarity Calculation: A function to calculate Jaccard similarity between responses based on shared words, which helps identify when models are saying similar things in different ways. Outlier Detection: A method to identify and remove outlier responses that have low average similarity with other responses. Clustering Algorithm: A clustering approach that groups responses based on their similarity, allowing us to identify the "majority opinion" among the models. Consensus Extraction: Logic to extract the common information from the largest cluster of similar responses, with priority given to higher confidence responses within that cluster. Confidence Calculation: A system to calculate the overall confidence in the consensus based on: The proportion of models that agree (cluster size relative to total responses) The average confidence scores of models in the majority cluster

# Why is this tool important?
In a world of abundant generative AI, we need tools to parse truth from fiction, and be able to consider information with some confidence, so this tool tries to compare multiple (LLM) model outputs to arrive at a single consensus response (with text that is extracted from multiple models with statistical rigor ), which can be stored in decentralised public annals, with timestamps for relevance. Informative Output: The app generates a consensus response from multiple LLM outputs, after eliminating wild hallucinations and outlier responses, and the output includes confidence levels and a disclaimer about the nature of AI-generated advice, which is especially important for medical contexts. Analysis Function: A function that provides detailed analysis of the consensus visually and textually. This implementation eliminates outlier responses through similarity analysis Includes only high-consensus information by clustering similar responses Provides confidence intervals through the consensus confidence calculation Suitable for high fidelity scenarios such as medical diagnosis by emphasizing agreement among models and including appropriate disclaimers The system now provides not just a single response (consensus response along with a verified model output), but information about how confident we can be in that consensus, which is crucial for critical applications requiring precision and accuracy like medical diagnosis, space, scientific missions etc. While this is not meant to be a substitute for human precision and judgement, tools such as this are a step towards Artificial General Intelligence.


# Technical Implementation 
A Community-built, Verifiable Knowledge Base
truthful.ai is a platform driven by AI for consensus learning that generates and validates knowledge through multi-model verification, statistical analysis, and blockchain-based immutability.

# Trusted Knowledge Hub - Monad Edition - Deployment

App front end deployed at [https://trusted-knowledge-hub.vercel.app]. (please note, the front end deployed here is an interim version and not the final version. The final code version on githuib has Monad blockchain features integrated and contracts deployed on Monad network.)

TruthToken deployed at: 0xFb75AfE2F631fC2935D8e4D293D26aeC5fd718A1
TrustedVerification deployed at: 0x9dEECfCF14c9F2a321aE65e4cd18169A47de6945

## ðŸš€ Key Features
- **Decentralised Monad-Powered Consensus of AI-generated content** : High throughput 10,000 TPS validation on Monad
- **Staking Mechanism**: `TRUTH` token staking contract (ERC-20 compatible)
- **ZK-Proof Verification**: Private voting using zk-SNARKs 
- **Real-Time Dashboard**: Monad EVM block explorer integration
- ** Dedicated ZK utilities for Monad blockchain
- ** Enhanced verification badge to display ZK verification status
- ** Smart contract integration for voting on content validity
- ** Transaction recording on Monad blockchain with content hash verification
- ** Created verification metadata generation with validator signatures

## Truth Token & Tokenomics
- ** Token Incentives System
- ** Implemented $TRUTH token dashboard for staking and rewards
- ** Added token reward claiming for accurate submissions and validations
- ** Created UI for displaying token incentives and earning opportunities

## On-Chain Governance
- ** Added DAO governance panel for voting on proposals
- ** Implemented proposal creation and voting mechanics
- ** Integrated staking for voting power in governance decisions


## ðŸ›  Quick Start
Install dependencies
npm install @monadchain/sdk @wagmi/core

Configure environment
cp .env.example .env

Add your MONAD_RPC_URL and wallet config
Start local node
npx hardhat node --network monad

text

## ðŸ”— Monad Integrations
| Component          | Monad Advantage                  |
|---------------------|----------------------------------|
| Consensus Protocol  | 1-second finality via pipelining |
| Data Storage        | Low-cost calldata storage        |
| DAO Governance      | EVM-compatible voting            |


# Overview
truthful.ai addresses a critical challenge in the AI era: determining the reliability of information. By leveraging multiple LLM responses to the same query, analyzing their consensus patterns, and permanently recording verified answers, we create a trustworthy knowledge repository that grows more valuable over time.

# What technologies are used for this project?
This project is built with:

Vite
TypeScript
React
shadcn-ui
Tailwind CSS
Multiple LLMs and AI apps

# Key Features
Multi-model Consensus: Queries multiple AI models for verification
Statistical Validation: Analyzes response similarity and confidence metrics
Blockchain Permanence: Stores verified answers on Monad blockchain / Flare blockchain TEE
Temporal Context: Timestamps all knowledge entries for relevance tracking
Community Governance: Enables community participation in knowledge validation

# How It Works
User submits a query to the truthful.ai platform
System distributes the query to multiple LLM endpoints
AI models generate independent responses
Consensus engine analyzes responses for similarity and confidence
System generates a consolidated answer with statistical metrics
Verified knowledge is stored on the blockchain with timestamp
Knowledge base grows as a valuable intellectual asset and public good

## Getting Started
Prerequisites
Node.js v16+
Python 3.9+
API keys for supported LLMs
Monad network access credentials
Installation

bash
Copy
git clone https://github.com/agentzeta/trusted-knowledge-on-monad.git
cd trusted-knowledge-on-monad
npm install
Configuration
Create a .env file in the root directory with the following variables:


Copy
OPENAI_API_KEY=your_openai_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
FLARE_NODE_URL=your_flare_node_url
FLARE_PRIVATE_KEY=your_flare_private_key
Running the Application
bash

Copy
npm start
The application will be available at http://localhost:3000.

# Project Structure

Copy
trusted-knowledge-hub/
â”œâ”€â”€ client/                # Frontend React application
â”œâ”€â”€ server/                # Backend Node.js server
â”‚   â”œâ”€â”€ controllers/       # Request handlers
â”‚   â”œâ”€â”€ models/            # Data models
â”‚   â”œâ”€â”€ services/          # Business logic
â”‚   â”‚   â”œâ”€â”€ ai-services/   # LLM integration
â”‚   â”‚   â””â”€â”€ blockchain/    # Flare blockchain integration
â”‚   â””â”€â”€ utils/             # Helper functions
â”œâ”€â”€ consensus-engine/      # Python-based consensus analysis
â””â”€â”€ docs/                  # Documentation
Contribution
truthful.ai is designed as a community project. Contributions are welcome in the following areas:


# .env
# Monad Network
MONAD_RPC_URL=your_monad_rpc_url_here
PRIVATE_KEY=0xyour_private_key_here

# Contract Addresses (to be filled after deployment)
VERIFICATION_CONTRACT_ADDRESS=0x9dEECfCF14c9F2a321aE65e4cd18169A47de6945
TRUTH_TOKEN_ADDRESS=0xFb75AfE2F631fC2935D8e4D293D26aeC5fd718A1

# Optional: For development
MONAD_CHAIN_ID=1

# foundry.toml
[profile.default]
src = "contracts"
out = "out"
libs = ["lib"]
solc_version = "0.8.13"  # Adjust to match your contract's pragma

[rpc_endpoints]
monad = "${MONAD_RPC_URL}"

# script directory
# script/Deploy.s.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "../contracts/TruthToken.sol";
import "../contracts/TrustedVerification.sol";

contract DeployScript is Script {
    function run() public {
        // Read the private key from environment and add 0x prefix if needed
        string memory rawKey = vm.envString("PRIVATE_KEY");
        bytes memory rawKeyBytes = bytes(rawKey);
        
        // Check if key already has 0x prefix
        bool hasPrefix = rawKeyBytes.length >= 2 && rawKeyBytes[0] == '0' && rawKeyBytes[1] == 'x';
        
        // Convert to uint256
        uint256 deployerPrivateKey;
        if (hasPrefix) {
            deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        } else {
            // Add 0x prefix and parse
            deployerPrivateKey = vm.parseUint(string(abi.encodePacked("0x", rawKey)));
        }
        
        address deployer = vm.addr(deployerPrivateKey);
        
        // Start broadcasting transactions
        vm.startBroadcast(deployerPrivateKey);

        // Deploy TruthToken
        TruthToken truthToken = new TruthToken(deployer);
        console.log("TruthToken deployed to:", address(truthToken));

        // Deploy TrustedVerification
        TrustedVerification trustedVerification = new TrustedVerification(
            address(truthToken),
            deployer
        );
        console.log("TrustedVerification deployed to:", address(trustedVerification));

        vm.stopBroadcast();

        // Log the addresses to make it easy to update .env
        console.log("\nUpdate your .env file with these values:");
        console.log("TRUTH_TOKEN_ADDRESS=", address(truthToken));
        console.log("VERIFICATION_CONTRACT_ADDRESS=", address(trustedVerification));
    }
}

# contracts directory
# contracts/Test.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

contract Test {
    function hello() public pure returns (string memory) {
        return "Hello, World!";
    }
}

# MonadService.ts (location may vary)
import { ethers } from 'ethers';
import { ZkProof } from '../types/blockchain';
import { VERIFICATION_ABI } from '../constants/abi';
import * as dotenv from 'dotenv';

dotenv.config();

export class MonadService {
  private provider: ethers.providers.JsonRpcProvider;
  private signer: ethers.Signer;
  
  // Hardcoded contract addresses as fallback
  private readonly VERIFICATION_CONTRACT_ADDRESS = '0x9dEECfCF14c9F2a321aE65e4cd18169A47de6945';
  private readonly TRUTH_TOKEN_ADDRESS = '0xFb75AfE2F631fC2935D8e4D293D26aeC5fd718A1';

  constructor() {
    this.provider = new ethers.providers.JsonRpcProvider(process.env.MONAD_RPC_URL);
    this.signer = new ethers.Wallet(process.env.PRIVATE_KEY!, this.provider);
  }

  async submitVerification(contentHash: string, zkProof: ZkProof) {
    const contractAddress = process.env.VERIFICATION_CONTRACT_ADDRESS || this.VERIFICATION_CONTRACT_ADDRESS;
    
    const contract = new ethers.Contract(
      contractAddress,
      VERIFICATION_ABI,
      this.signer
    );

    const tx = await contract.submitVerification(contentHash, zkProof);
    return await tx.wait();
  }

  async getVerificationStatus(contentHash: string) {
    const contractAddress = process.env.VERIFICATION_CONTRACT_ADDRESS || this.VERIFICATION_CONTRACT_ADDRESS;
    
    const contract = new ethers.Contract(
      contractAddress,
      VERIFICATION_ABI,
      this.provider
    );

    return await contract.verificationStatus(contentHash);
  }
}



# Adding support for additional LLM providers
Improving consensus algorithms
Enhancing the user interface
Building tools to explore the knowledge base
Developing governance mechanisms
Please see CONTRIBUTING.md for details.

# Roadmap
Phase 1: Initial platform with basic consensus engine and blockchain storage
Phase 2: Enhanced statistical analysis and confidence metrics
Phase 3: Community governance mechanisms
Phase 4: API access to the verified knowledge base
Phase 5: Integration with other knowledge tools and platforms
License
This project was created at UC Berkely & Stanford campuses for a coding challenge.
This project needs your valued validation to build a much needed public good - web3's first truth layer - a verifiable community-built knowledge hub of consensus AI output made possible with human-AI collaboration. 

# Contact
GitHub: https://github.com/agentzeta/trusted-knowledge-on-monad
Email: himalayalabs@gmail.com

## ðŸ“œ License
MIT License (Monad Hackathon Edition)
